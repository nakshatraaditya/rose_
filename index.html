<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>A Question for You...</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;700&family=Playfair+Display:ital,wght@0,600;0,700;1,600&display=swap" rel="stylesheet">

  <style>
    /* =========================================
       1. CSS VARIABLES & RESET
       ========================================= */
    :root {
      --bg-color: #000000;
      --card-bg: #F5F1E8;          /* Warm Cream */
      --text-main: #2D2424;        /* Soft Black */
      --text-sub: #635858;         /* Warm Grey */
      --accent-pink: #E85D75;      /* Romantic Pink */
      --accent-hover: #D0455E;
      --btn-shadow: 0 10px 28px rgba(232, 93, 117, 0.35);
    }

    * { box-sizing: border-box; }

    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background-color: var(--bg-color);
      overflow: hidden;
      font-family: 'DM Sans', sans-serif;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    /* =========================================
       2. CANVAS BACKGROUND (Z-INDEX 1)
       ========================================= */
    canvas#garden {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      display: block;
    }

    /* =========================================
       3. UI FOREGROUND (Z-INDEX 10)
       ========================================= */
    .ui-overlay {
      position: relative;
      z-index: 10;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
      pointer-events: none;
    }

    /* Vignette + soft bloom overlay */
    .ui-overlay::before{
      content:"";
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 9;
      background:
        radial-gradient(80% 60% at 50% 45%, rgba(232,93,117,0.08), transparent 60%),
        radial-gradient(120% 90% at 50% 55%, rgba(0,0,0,0.35), rgba(0,0,0,0.85));
    }

    @keyframes fadeUp {
      to { opacity: 1; transform: translateY(0); }
    }

    .card {
      background: var(--card-bg);
      width: 100%;
      max-width: 420px;
      border-radius: 28px;
      padding: 0 30px 40px 30px;
      text-align: center;
      position: relative;
      pointer-events: auto;

      box-shadow:
        0 30px 70px rgba(0,0,0,0.60),
        0 10px 25px rgba(0,0,0,0.25);

      border: 1px solid rgba(255,255,255,0.55);

      opacity: 0;
      transform: translateY(30px);
      animation: fadeUp 1s cubic-bezier(0.2, 0.8, 0.2, 1) forwards 0.5s;
    }

    .card::before{
      content:"";
      position:absolute;
      inset: 1px;
      border-radius: 27px;
      pointer-events:none;
      background: radial-gradient(120% 90% at 50% 0%,
        rgba(255,255,255,0.65), rgba(255,255,255,0.0) 55%);
      opacity: 0.55;
    }

    /* =========================================
       4. CHARACTER BADGE (ON TOP OF CARD)
       ========================================= */
    @keyframes charFloat {
      0%, 100% { transform: translateY(0) rotate(-1.2deg); }
      50%      { transform: translateY(-10px) rotate(1.2deg); }
    }

    .hero-image-wrapper {
      width: 140px;
      height: 140px;
      margin: -74px auto 18px auto;
      position: relative;
      border-radius: 999px;

      background: rgba(245,241,232,0.96);
      border: 6px solid rgba(255,255,255,0.9);

      box-shadow:
        0 22px 45px rgba(0,0,0,0.30),
        0 8px 18px rgba(0,0,0,0.18);

      display: grid;
      place-items: center;

      animation: charFloat 2.8s ease-in-out infinite;
      will-change: transform;
      z-index: 2;
    }

    .hero-image-wrapper::after{
      content:"";
      position:absolute;
      inset:-10px;
      border-radius: 999px;
      background: radial-gradient(circle, rgba(232,93,117,0.18), transparent 60%);
      filter: blur(2px);
      opacity: 0.85;
      pointer-events:none;
    }

    /* Video hero (replaces static image) */
    .hero-video {
      width: 104px;
      height: 104px;
      object-fit: contain; /* avoid cropping important parts */
      border-radius: 18px;
      user-select: none;
      -webkit-user-drag: none;

      /* Best-effort "crisp pixel" handling (varies by browser) */
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      transform: translateZ(0);
      backface-visibility: hidden;
    }

    /* =========================================
       4B. PIXEL DIALOGUE BUBBLE (NEAR HEAD)
       ========================================= */
    @keyframes bubbleIn {
      from { opacity: 0; transform: translateY(6px) scale(0.98); }
      to   { opacity: 1; transform: translateY(0) scale(1); }
    }

    .dialogue {
      position: absolute;
      z-index: 3;

      /* anchor next to the hero "head" */
      top: 34px;
      left: 50%;
      transform: translateX(calc(-50% + clamp(86px, 20vw, 122px)));

      width: min(280px, calc(100vw - 70px));
      pointer-events: auto;

      opacity: 0;
      animation: bubbleIn 420ms ease forwards;
      filter: drop-shadow(0 10px 18px rgba(0,0,0,0.25));
    }

    /* bubble body with subtle pixel-step corners */
    .dialogue .bubble {
      background: rgba(245,241,232,0.98);
      border: 2px solid rgba(45,36,36,0.14);
      padding: 14px 14px 12px 14px;

      /* stepped/pixel-ish corners */
      clip-path: polygon(
        10px 0%, calc(100% - 10px) 0%,
        100% 10px, 100% calc(100% - 14px),
        calc(100% - 10px) 100%, 14px 100%,
        0% calc(100% - 10px), 0% 10px
      );

      box-shadow:
        0 18px 35px rgba(0,0,0,0.22),
        0 8px 18px rgba(0,0,0,0.14);
    }

    /* tail pointing toward character head */
    .dialogue .tail {
      position: absolute;
      left: 18px;
      bottom: -10px;
      width: 22px;
      height: 22px;
      background: rgba(245,241,232,0.98);
      border-left: 2px solid rgba(45,36,36,0.14);
      border-bottom: 2px solid rgba(45,36,36,0.14);
      transform: rotate(45deg);
      clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%);
    }

    .bubble-text {
      font-family: 'Playfair Display', serif;
      font-size: 1.25rem;
      color: var(--text-main);
      line-height: 1.15;
      letter-spacing: -0.3px;
      margin: 0;
      text-align: left;
      min-height: 2.2em; /* keeps layout stable during typing */
      position: relative;
    }

    .bubble-caret {
      display: inline-block;
      width: 10px;
      margin-left: 2px;
      transform: translateY(-1px);
      opacity: 0.75;
      animation: caretBlink 0.8s infinite steps(1);
    }
    @keyframes caretBlink { 50% { opacity: 0; } }

    .bubble-actions {
      display: none; /* shown after typing finishes */
      margin-top: 12px;
      justify-content: flex-start;
      gap: 10px;
      align-items: center;
    }

    /* =========================================
       5. TYPOGRAPHY (kept for success state)
       ========================================= */
    h1 {
      font-family: 'Playfair Display', serif;
      font-size: 2rem;
      color: var(--text-main);
      margin: 0 0 10px 0;
      line-height: 1.15;
      letter-spacing: -0.5px;
      position: relative;
      z-index: 2;
    }

    p.subtext {
      font-size: 0.98rem;
      color: var(--text-sub);
      margin: 0 0 30px 0;
      line-height: 1.55;
      position: relative;
      z-index: 2;
    }

    /* =========================================
       6. BUTTONS (unchanged)
       ========================================= */
    .actions {
      display: flex;
      justify-content: center;
      gap: 15px;
      position: relative;
      min-height: 64px;
      z-index: 2;
    }

    .btn {
      border: none;
      padding: 14px 32px;
      font-size: 1rem;
      font-weight: 700;
      border-radius: 999px;
      cursor: pointer;
      transition: transform 0.18s ease, box-shadow 0.18s ease, background-color 0.18s ease, opacity 0.25s ease;
      font-family: 'DM Sans', sans-serif;
      outline: none;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    .btn-yes {
      background-color: var(--accent-pink);
      color: white;
      box-shadow: var(--btn-shadow);
    }

    .btn-yes:hover {
      background-color: var(--accent-hover);
      transform: translateY(-2px);
      box-shadow: 0 14px 34px rgba(232, 93, 117, 0.55);
    }

    .btn-yes:active { transform: translateY(0); }

    .btn-no {
      background-color: #E0E0E0;
      color: var(--text-sub);
      transition: transform 0.22s ease, opacity 0.25s ease, left 0.28s ease, top 0.28s ease;
      will-change: left, top;
    }

    /* =========================================
       7. SUCCESS STATE (unchanged)
       ========================================= */
    .success-state {
      display: none;
      flex-direction: column;
      align-items: center;
      animation: fadeIn 0.5s ease;
      position: relative;
      z-index: 2;
      margin-top: 8px;
    }

    .success-state h2 {
      font-family: 'Playfair Display', serif;
      color: var(--accent-pink);
      font-size: 2.2rem;
      margin: 0;
    }

    .success-state p {
      color: var(--text-sub);
      margin-top: 6px;
      margin-bottom: 0;
    }

    .emoji-confetti {
      font-size: 3rem;
      margin-top: 10px;
      animation: bounce 1s infinite alternate;
    }

    @keyframes bounce { from { transform: translateY(0); } to { transform: translateY(-10px); } }
    @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }

    /* small optional micro celebration near character (subtle) */
    .micro-celebration {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 4;
      opacity: 0;
    }
    .micro-celebration.show {
      opacity: 1;
      animation: microPop 520ms ease forwards;
    }
    @keyframes microPop {
      0%   { transform: translateY(0) scale(0.95); opacity: 0; }
      35%  { transform: translateY(-6px) scale(1.02); opacity: 1; }
      100% { transform: translateY(-10px) scale(1); opacity: 0; }
    }

    /* Optional: respect reduced motion */
    @media (prefers-reduced-motion: reduce) {
      .card, .hero-image-wrapper, .emoji-confetti, .dialogue { animation: none !important; }
      .btn, .btn-no { transition: none !important; }
      .bubble-caret { animation: none !important; }
    }
  </style>
</head>
<body>

  <canvas id="garden"></canvas>

  <div class="ui-overlay">
    <div class="card" id="card">

      <div class="hero-image-wrapper" id="heroWrap">
        <!-- Replace src with your deployed video path/filename -->
        <video
          class="hero-video"
          id="heroVideo"
          src="Pixel_Art_Character_Animation_Request.mp4"
          autoplay
          muted
          loop
          playsinline
          preload="auto"
        ></video>

        <div class="micro-celebration" id="microCelebration">‚ú®</div>
      </div>

      <!-- Pixel dialogue bubble near the character head -->
      <div class="dialogue" id="dialogue">
        <div class="bubble">
          <p class="bubble-text">
            <span id="bubbleText"></span><span class="bubble-caret" id="bubbleCaret">‚ñå</span>
          </p>

          <div class="bubble-actions" id="bubbleActions">
            <!-- Buttons keep the same IDs and behavior -->
            <button class="btn btn-yes" id="yesBtn">Yes</button>
            <button class="btn btn-no" id="noBtn" tabindex="0">No</button>
          </div>
        </div>
        <div class="tail" aria-hidden="true"></div>
      </div>

      <div id="question-state" style="display:block;">
        <!-- content moved to bubble (keeping state wrapper for existing logic) -->
      </div>

      <div id="success-state" class="success-state">
        <h2>Yay!</h2>
        <div class="emoji-confetti">üíê üíñ ‚ú®</div>
        <p>See you on the 14th!</p>
      </div>

    </div>
  </div>

  <script>
    /* =========================================
       PART A: THE PIXEL GARDEN
       ========================================= */
    const canvas = document.getElementById('garden');
    const ctx = canvas.getContext('2d');
    let width, height;
    let roses = [];
    const PIXEL_SIZE = 4;
    const GRID_ALIGN = true;

    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
      initGarden();
      positionDialogue(); // keep bubble near head on resize
    }
    window.addEventListener('resize', resize);

    function random(min, max) { return Math.random() * (max - min) + min; }

    class Rose {
      constructor() { this.init(); }

      init() {
        this.x = random(width * 0.05, width * 0.95);
        this.y = random(height * 0.1, height * 0.95);
        const hue = random(330, 360);
        this.color = `hsl(${hue}, 80%, 50%)`;
        this.glowColor = `hsl(${hue}, 100%, 70%)`;
        this.phase = random(0, Math.PI * 2);
        this.speed = random(0.005, 0.015);
        this.scale = random(2, 4);
        this.maxBloom = random(0.8, 1.2);
        this.swayOffset = random(0, 100);
        this.swaySpeed = random(0.001, 0.003);
      }

      update(time) {
        const t = time * this.speed + this.phase;
        const cycle = (Math.sin(t) + 1) / 2;
        const bloomLevel = Math.min(cycle * 1.5, 1) * this.maxBloom;

        let alpha = 1;
        let glow = 0;

        if (cycle > 0.8) {
          glow = (cycle - 0.8) * 100;
          alpha = 0.8 + Math.sin(time * 0.1) * 0.2;
        } else if (cycle < 0.2) {
          alpha = cycle * 5;
        }

        this.draw(bloomLevel, alpha, glow);
      }

      drawPixel(relX, relY, color, alpha) {
        ctx.fillStyle = color;
        ctx.globalAlpha = alpha;

        let drawX = this.x + (relX * PIXEL_SIZE * this.scale);
        let drawY = this.y + (relY * PIXEL_SIZE * this.scale);

        const sway = Math.sin(Date.now() * this.swaySpeed + this.swayOffset) * (20 * this.scale);
        drawX += sway;

        if (GRID_ALIGN) {
          drawX = Math.floor(drawX / PIXEL_SIZE) * PIXEL_SIZE;
          drawY = Math.floor(drawY / PIXEL_SIZE) * PIXEL_SIZE;
        }

        ctx.fillRect(drawX, drawY, PIXEL_SIZE * this.scale, PIXEL_SIZE * this.scale);
      }

      draw(bloom, alpha, glowLevel) {
        if (bloom > 0.1) {
          for (let i = 1; i < 6; i++) {
            this.drawPixel(0, i + 2, '#2d6e32', alpha);
            if (i === 3) {
              this.drawPixel(-1, i + 2, '#2d6e32', alpha);
              this.drawPixel(1, i + 3, '#2d6e32', alpha);
            }
          }
        }

        if (bloom > 0.2) this.drawPixel(0, 0, '#601120', alpha);
        if (bloom > 0.3) this.drawPixel(0, 1, '#601120', alpha);

        if (bloom > 0.5) {
          this.drawPixel(-1, 0, this.color, alpha);
          this.drawPixel(1, 0, this.color, alpha);
          this.drawPixel(0, -1, this.color, alpha);
        }

        if (bloom > 0.8) {
          this.drawPixel(-1, -1, this.color, alpha);
          this.drawPixel(1, -1, this.color, alpha);
          this.drawPixel(-1, 1, this.color, alpha);
          this.drawPixel(1, 1, this.color, alpha);
          this.drawPixel(-2, 0, this.color, alpha);
          this.drawPixel(2, 0, this.color, alpha);
        }

        if (glowLevel > 0) {
          ctx.shadowBlur = glowLevel;
          ctx.shadowColor = this.glowColor;
        } else {
          ctx.shadowBlur = 0;
        }
      }
    }

    function initGarden() {
      roses = [];
      const count = Math.floor((width * height) / 35000);
      for (let i = 0; i < count; i++) roses.push(new Rose());
    }

    function animate() {
      // solid black base every frame (crisp)
      ctx.fillStyle = "#000";
      ctx.shadowBlur = 0;
      ctx.fillRect(0, 0, width, height);

      const time = Date.now() * 0.001;
      roses.forEach(rose => rose.update(time));

      requestAnimationFrame(animate);
    }

    /* =========================================
       PART B: DIALOGUE (TYPING + TIMING)
       ========================================= */
    const dialogue = document.getElementById('dialogue');
    const bubbleTextEl = document.getElementById('bubbleText');
    const bubbleCaret = document.getElementById('bubbleCaret');
    const bubbleActions = document.getElementById('bubbleActions');
    const heroWrap = document.getElementById('heroWrap');

    function positionDialogue() {
      // Keep bubble near the hero head even as layout shifts
      // (We anchor relative to the card/hero; fine-tune tail direction if needed.)
      const heroRect = heroWrap.getBoundingClientRect();
      const cardRect = document.getElementById('card').getBoundingClientRect();

      // Place bubble slightly to the right and a bit above hero center
      const targetX = heroRect.left + heroRect.width * 0.62;
      const targetY = heroRect.top + heroRect.height * 0.18;

      // Convert viewport coords to card-local absolute positioning
      const xInCard = targetX - cardRect.left;
      const yInCard = targetY - cardRect.top;

      dialogue.style.left = xInCard + "px";
      dialogue.style.top = yInCard + "px";
      dialogue.style.transform = "translateX(clamp(54px, 16vw, 118px))";
    }

    function typeText(text, speed = 34) {
      bubbleTextEl.textContent = "";
      bubbleActions.style.display = "none";
      bubbleCaret.style.display = "inline-block";

      let i = 0;
      const t = setInterval(() => {
        bubbleTextEl.textContent += text[i];
        i++;
        if (i >= text.length) {
          clearInterval(t);
          bubbleCaret.style.display = "none";
          bubbleActions.style.display = "flex";
        }
      }, speed);
    }

    /* =========================================
       PART C: INTERACTION LOGIC (UNCHANGED)
       ========================================= */
    const yesBtn = document.getElementById('yesBtn');
    const noBtn = document.getElementById('noBtn');
    const questionState = document.getElementById('question-state');
    const successState = document.getElementById('success-state');
    const card = document.getElementById('card');
    const microCelebration = document.getElementById('microCelebration');

    let noAttempts = 0;
    const MAX_ATTEMPTS = 5;

    function moveNoButton() {
      if (noAttempts >= MAX_ATTEMPTS) return;

      const safeMargin = 24;
      const btnRect = noBtn.getBoundingClientRect();
      const avoid = card.getBoundingClientRect();

      const maxX = window.innerWidth - btnRect.width - safeMargin;
      const maxY = window.innerHeight - btnRect.height - safeMargin;

      let randomX, randomY, tries = 0;

      // Avoid landing on top of the card for a cleaner feel
      do {
        randomX = safeMargin + Math.random() * maxX;
        randomY = safeMargin + Math.random() * maxY;
        tries++;
      } while (
        tries < 12 &&
        randomX > (avoid.left - btnRect.width) &&
        randomX < (avoid.right) &&
        randomY > (avoid.top - btnRect.height) &&
        randomY < (avoid.bottom)
      );

      noBtn.style.position = 'fixed';
      noBtn.style.left = randomX + 'px';
      noBtn.style.top = randomY + 'px';
      noBtn.style.zIndex = '100';

      // Tiny "whoosh" scale for delight
      noBtn.style.transform = 'scale(1.02)';
      setTimeout(() => noBtn.style.transform = 'scale(1)', 120);

      noAttempts++;

      if (noAttempts === MAX_ATTEMPTS) {
        noBtn.style.opacity = '0';
        noBtn.style.pointerEvents = 'none';
        setTimeout(() => {
          if (noBtn && noBtn.parentNode) noBtn.parentNode.removeChild(noBtn);
        }, 260);
      }
    }

    // Mouse / Touch / Click / Keyboard focus
    noBtn.addEventListener('mouseover', moveNoButton);
    noBtn.addEventListener('touchstart', (e) => { e.preventDefault(); moveNoButton(); }, { passive: false });
    noBtn.addEventListener('click', (e) => { e.preventDefault(); moveNoButton(); });
    noBtn.addEventListener('focus', moveNoButton);

    yesBtn.addEventListener('click', () => {
      // UI Transition (same behaviour)
      questionState.style.display = 'none';
      dialogue.style.display = 'none';
      successState.style.display = 'flex';

      // Pop the character badge a bit (same behaviour)
      heroWrap.animate(
        [
          { transform: 'translateY(0) rotate(-1deg) scale(1)' },
          { transform: 'translateY(-10px) rotate(1deg) scale(1.06)' },
          { transform: 'translateY(0) rotate(-1deg) scale(1)' }
        ],
        { duration: 420, easing: 'cubic-bezier(.2,.9,.2,1)' }
      );

      // Optional subtle micro-celebration near character (small)
      microCelebration.classList.remove("show");
      void microCelebration.offsetWidth;
      microCelebration.classList.add("show");

      // Garden Party Mode (same behaviour)
      roses.forEach(rose => {
        rose.color = '#FF6B81';
        rose.glowColor = '#FF9CA9';
        rose.speed *= 5;
        rose.swaySpeed *= 3;
      });
    });

    /* =========================================
       PART D: INIT
       ========================================= */
    resize();
    animate();

    // ensure dialogue tracks head position
    requestAnimationFrame(positionDialogue);
    setTimeout(positionDialogue, 250);

    // On page load: video visible and playing, bubble types in question, then buttons appear
    typeText("Will you be my Valentine?");
  </script>
</body>
</html>
