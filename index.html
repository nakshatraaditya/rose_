<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>8-Bit Garden</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #000; /* Deep black background */
            overflow: hidden; /* No scrollbars */
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="garden"></canvas>

    <script>
        const canvas = document.getElementById('garden');
        const ctx = canvas.getContext('2d');

        let width, height;
        let roses = [];
        
        // Configuration for the 8-bit feel
        const PIXEL_SIZE = 4; // Size of one "pixel"
        const GRID_ALIGN = true; // Snap to grid for retro feel

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            initGarden();
        }

        window.addEventListener('resize', resize);

        // Utility: Random Range
        function random(min, max) {
            return Math.random() * (max - min) + min;
        }

        class Rose {
            constructor() {
                this.init();
            }

            init() {
                // Position (Keep within bounds but random)
                this.x = random(width * 0.1, width * 0.9);
                this.y = random(height * 0.2, height * 0.9);
                
                // Varied colors (Reds, Pinks, deep Purples)
                const hue = random(330, 360); 
                this.color = `hsl(${hue}, 80%, 50%)`;
                this.glowColor = `hsl(${hue}, 100%, 70%)`;
                
                // Animation State
                this.phase = random(0, Math.PI * 2); // Random start time
                this.speed = random(0.005, 0.015); // Very slow speed
                this.scale = random(2, 4); // Size of the flower
                this.maxBloom = random(0.8, 1.2);
                
                // Sway mechanics
                this.swayOffset = random(0, 100);
                this.swaySpeed = random(0.001, 0.003);
            }

            drawPixel(relX, relY, color, alpha) {
                ctx.fillStyle = color;
                ctx.globalAlpha = alpha;
                
                // Calculate absolute position
                let drawX = this.x + (relX * PIXEL_SIZE * this.scale);
                let drawY = this.y + (relY * PIXEL_SIZE * this.scale);

                // Sway math
                const sway = Math.sin(Date.now() * this.swaySpeed + this.swayOffset) * (20 * this.scale);
                // Apply sway more to the top (y-0) than the bottom
                // Roses are drawn relative to center, so we adjust based on height
                drawX += sway;

                // Snap to grid for 8-bit look
                if (GRID_ALIGN) {
                    drawX = Math.floor(drawX / PIXEL_SIZE) * PIXEL_SIZE;
                    drawY = Math.floor(drawY / PIXEL_SIZE) * PIXEL_SIZE;
                }

                ctx.fillRect(drawX, drawY, PIXEL_SIZE * this.scale, PIXEL_SIZE * this.scale);
            }

            update(time) {
                // Cycle: 0 -> 1 (Bloom) -> Sway -> 1 -> 0 (Fade)
                // We use a sine wave mapped to 0-1 range for the life cycle
                // Adding a slow time component
                
                const t = time * this.speed + this.phase;
                // cycle is 0 to 1
                const cycle = (Math.sin(t) + 1) / 2; 
                
                // Apply logic stages
                // Bloom: 0.0 to 0.7
                // Pulse/Glow: 0.7 to 1.0
                
                const bloomLevel = Math.min(cycle * 1.5, 1) * this.maxBloom; 
                
                // Pulse opacity slightly at full bloom
                let alpha = 1;
                let glow = 0;
                
                if (cycle > 0.8) {
                    // Pulsing Glow Phase
                    glow = (cycle - 0.8) * 100; // 0 to 20 range
                    alpha = 0.8 + Math.sin(time * 0.1) * 0.2;
                } else if (cycle < 0.2) {
                    // Fading out/in
                    alpha = cycle * 5; 
                }

                this.draw(bloomLevel, alpha, glow);
            }

            draw(bloom, alpha, glowLevel) {
                // Pixel Map for a Rose
                // We draw procedural layers based on "bloom" progress
                
                // STEM (Green)
                // Only draw stem if partially bloomed
                if (bloom > 0.1) {
                    const stemHeight = 6;
                    for (let i = 1; i < stemHeight; i++) {
                        this.drawPixel(0, i + 2, '#2d6e32', alpha); 
                        // Leaves
                        if (i === 3) {
                             this.drawPixel(-1, i + 2, '#2d6e32', alpha);
                             this.drawPixel(1, i + 3, '#2d6e32', alpha);
                        }
                    }
                }

                // PETALS
                // Center
                if (bloom > 0.2) this.drawPixel(0, 0, '#601120', alpha);
                if (bloom > 0.3) this.drawPixel(0, 1, '#601120', alpha);

                // Inner Ring
                if (bloom > 0.5) {
                    this.drawPixel(-1, 0, this.color, alpha);
                    this.drawPixel(1, 0, this.color, alpha);
                    this.drawPixel(0, -1, this.color, alpha);
                }

                // Outer Ring (Full Bloom)
                if (bloom > 0.8) {
                    this.drawPixel(-1, -1, this.color, alpha);
                    this.drawPixel(1, -1, this.color, alpha);
                    this.drawPixel(-1, 1, this.color, alpha);
                    this.drawPixel(1, 1, this.color, alpha);
                    this.drawPixel(-2, 0, this.color, alpha);
                    this.drawPixel(2, 0, this.color, alpha);
                }

                // Glow Effect (Canvas Shadow)
                if (glowLevel > 0) {
                    ctx.shadowBlur = glowLevel;
                    ctx.shadowColor = this.glowColor;
                } else {
                    ctx.shadowBlur = 0;
                }
            }
        }

        function initGarden() {
            roses = [];
            // Create density based on screen size
            const count = Math.floor((width * height) / 40000);
            for (let i = 0; i < count; i++) {
                roses.push(new Rose());
            }
        }

        function animate() {
            // Clear screen with slight trail effect (optional, strictly black here for crispness)
            ctx.fillStyle = '#000';
            ctx.shadowBlur = 0; // Reset shadow for background clear
            ctx.fillRect(0, 0, width, height);

            const time = Date.now() * 0.001;

            roses.forEach(rose => {
                rose.update(time);
            });

            requestAnimationFrame(animate);
        }

        // Start
        resize();
        animate();

    </script>
</body>
</html>
